Bluetooth: qca: fix invalid device address check

The WCN6750 (and other QCA) Bluetooth chips use a default/placeholder BD address
of 00:00:00:00:5A:AD when not provisioned with a valid address.

The current qca_check_bdaddr() function has two critical issues:

1. It returns early if hdev->public_addr is set to anything other than all
   zeros, which prevents checking if the device has the invalid placeholder
address.
2. It incorrectly compares the device's BD address against config->bdaddr (which
   is initialized to all zeros), instead of the actual default placeholder
   address.

This means the HCI_QUIRK_USE_BDADDR_PROPERTY quirk never gets set, and the device
fails to initialize properly with EOPNOTSUPP.

Based on upstream Linux kernel commit 32868e126c78 by Johan Hovold
<johan+linaro@kernel.org>.

Note: The 6.17.y kernel already has a partial implementation of this fix with
qca_check_bdaddr() present but using the wrong comparison and early return. This
patch completes the fix by removing the early return, adding the constant, and
correcting the comparison.

diff --git a/drivers/bluetooth/btqca.c b/drivers/bluetooth/btqca.c
index 7c958d6065be..ad3c81a2bd37 100644
--- a/drivers/bluetooth/btqca.c
+++ b/drivers/bluetooth/btqca.c
@@ -714,15 +714,12 @@ int qca_set_bdaddr_rome(struct hci_dev *hdev, const bdaddr_t *bdaddr)
 }
 EXPORT_SYMBOL_GPL(qca_set_bdaddr_rome);
 
-static int qca_check_bdaddr(struct hci_dev *hdev, const struct qca_fw_config *config)
+static int qca_check_bdaddr(struct hci_dev *hdev)
 {
 	struct hci_rp_read_bd_addr *bda;
 	struct sk_buff *skb;
 	int err;
 
-	if (bacmp(&hdev->public_addr, BDADDR_ANY))
-		return 0;
-
 	skb = __hci_cmd_sync(hdev, HCI_OP_READ_BD_ADDR, 0, NULL,
 			     HCI_INIT_TIMEOUT);
 	if (IS_ERR(skb)) {
@@ -738,7 +735,7 @@ static int qca_check_bdaddr(struct hci_dev *hdev, const struct qca_fw_config *co
 	}
 
 	bda = (struct hci_rp_read_bd_addr *)skb->data;
-	if (!bacmp(&bda->bdaddr, &config->bdaddr))
+	if (!bacmp(&bda->bdaddr, QCA_BDADDR_DEFAULT))
 		hci_set_quirk(hdev, HCI_QUIRK_USE_BDADDR_PROPERTY);
 
 	kfree_skb(skb);
@@ -993,7 +990,7 @@ int qca_uart_setup(struct hci_dev *hdev, uint8_t baudrate,
 		break;
 	}
 
-	err = qca_check_bdaddr(hdev, &config);
+	err = qca_check_bdaddr(hdev);
 	if (err)
 		return err;
 
diff --git a/drivers/bluetooth/btqca.h b/drivers/bluetooth/btqca.h
index 8f3c1b1c77b3..cf0bdc375de1 100644
--- a/drivers/bluetooth/btqca.h
+++ b/drivers/bluetooth/btqca.h
@@ -54,6 +54,9 @@
 #define QCA_HSP_GF_SOC_ID		0x1200
 #define QCA_HSP_GF_SOC_MASK		0x0000ff00
 
+/* Default BD address for devices without valid address provisioned. */
+#define QCA_BDADDR_DEFAULT (&(bdaddr_t) {{0xad, 0x5a, 0x00, 0x00, 0x00, 0x00}})
+
 enum qca_baudrate {
 	QCA_BAUDRATE_115200	= 0,
 	QCA_BAUDRATE_57600,
